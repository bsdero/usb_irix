/*
********************************************************************
* PCI EHCI Device Driver for Irix 6.5                              *
*                                                                  *
* Programmed by BSDero                                             *
* bsdero at gmail dot com                                          *
*                                                                  *
* 2011                                                             *
*                                                                  *
********************************************************************

*******************************************************************************************************
* FIXLIST (latest at top)                                                                             *
*-----------------------------------------------------------------------------------------------------*
* Author      MM-DD-YYYY     Description                                                              *
*-----------------------------------------------------------------------------------------------------*
* BSDero      12-04-2011     -Added pfxpoll entry point. Fixes and basic events support               *
*                                                                                                     *
* BSDero      11-20-2011     -Crashes fixed in SGI Fuel                                               *
*                                                                                                     *
* BSDero      11-18-2011     -Added non O2 support                                                    *
*                                                                                                     *
* BSDero      11-01-2011     -Added pfxioctl entry point                                              *
*                                                                                                     *
* BSDero      10-31-2011     -Added trace macro                                                       *
*                                                                                                     *
* BSDero      10-15-2011     -Fixed bug in ehci_interrupt. Now ports connect/disconnect are correctly *
*                             detected                                                                *                                                                                                     *
*                                                                                                     *                                                                                                     *
* BSDero      10-12-2011     -Added support for pfxopen/pfxclose entry points                         *
*                                                                                                     *
* BSDero      10-11-2011     -Added connection/disconnection detect of USB devices                    *
*                            -Added USB device speed detect                                           *
*                            -Identify which ports are changed                                        *
*                                                                                                     *
* BSDero      10-10-2011     -Fixed crash on pciehci_detach()                                         *
*                            -EREAD/EWRITE and friend macros bug fixed.                               *
*                            -PCI Interrupts are working now                                          *
*                            -EHCI devices support added                                              *
*                            -Fixed crash on pciehci_dma_intr                                         *
*                                                                                                     *
* BSDero      10-01-2011     -Added initial support for another USB controller. Taken from NetBSD     * 
*                                                                                                     *
* BSDero      09-24-2011     -Code ripped from FreeBSD for EHCI, PCI EHCI interrupts not working yet  *
*                            -Macros for NetBSD source code compatibility                             *
*                            -Added basic data types                                                  *
*                                                                                                     *
* BSDero      09-17-2011     -Added support for basic ehci PCI map                                    *
*                            -Basic configurations registers read                                     *
*                                                                                                     *
* BSDero      09-10-2011     -Initial version -taken from SGI Driver Developers Guide                 *
*******************************************************************************************************
VERSION: 0.0.4


WARNING!!!

EXPERIMENTAL DRIVER FOR EHCI, NOT USEFUL YET, USE IT UNDER UR OWN RISK!!!
NOR STABLE NOR ENOUGH TESTED!!
*/

#include <sys/types.h>
#include <sys/cpu.h>
#include <sys/systm.h>
#include <sys/cmn_err.h>
#include <sys/errno.h>
#include <sys/buf.h>
#include <sys/ioctl.h>
#include <sys/cred.h>
#include <ksys/ddmap.h>
#include <sys/poll.h>
#include <sys/invent.h>
#include <sys/debug.h>
#include <sys/sbd.h>
#include <sys/kmem.h>
#include <sys/edt.h>
#include <sys/dmamap.h>
#include <sys/hwgraph.h>
#include <sys/iobus.h>
#include <sys/iograph.h>
#include <sys/param.h>
#include <sys/pio.h>
#include <sys/sema.h>
#include <sys/ddi.h>
#include <sys/atomic_ops.h>
#include <sys/PCI/PCI_defs.h>
#include <sys/PCI/pciio.h>

#include <sys/mload.h>
#include <string.h>

/* included sources */

#include "dumphex.c"
#include "list.c"
#include "gc.c"
#include "dma.c"
#include "hcicommon.h"
#include "ehcireg.h"
#include "pciehci.h"



/************************************************************************************
 * EHCI SPECIFIC DEFINES AND MACROS                                                 *
 ************************************************************************************/

 /* PCI configuration offset */
#define EHCI_CF_VENDOR_ID                           0x00
#define EHCI_CF_DEVICE_ID                           0x02
#define EHCI_CF_COMMAND                             0x04
#define EHCI_CF_STATUS                              0x06
#define EHCI_CF_REVISION_ID                         0x08
#define EHCI_CF_CLASS_CODE                          0x09
#define EHCI_CF_CACHE_LINE_SIZE                     0x0c
#define EHCI_CF_LATENCY_TIME                        0x0d
#define EHCI_CF_HEADER_TYPE                         0x0e
#define EHCI_CF_BIST                                0x0f
#define EHCI_CF_MMAP_IO_BASE_ADDR                   0x10
#define EHCI_CF_CIS_BASE_ADDR                       0x14
#define EHCI_CF_CARDBUS_CIS_PTR                     0x28
#define EHCI_CF_SSID                                0x2c
#define EHCI_CF_PWR_MGMT_CAPS                       0x34
#define EHCI_CF_INTERRUPT_LINE                      0x3c
#define EHCI_CF_INTERRUPT_PIN                       0x3d

/* PCI device specifics offset */
#define EHCI_DS_MISC_CTL_1                          0x40
#define EHCI_DS_MISC_CTL_2                          0x41
#define EHCI_DS_MISC_CTL_3                          0x42
#define EHCI_DS_MISC_CTL_4                          0x48
#define EHCI_DS_MISC_CTL_5                          0x49
#define EHCI_DS_MAC_INTER_TRANS_DELAY               0x4a
#define EHCI_DS_MAX_TURN_AROUND_TIME                0x4b
#define EHCI_DS_USB2_TIMEOUT_RX                     0x51
#define EHCI_DS_HI_SPEED_PPT                        0x5a
#define EHCI_DS_SERIAL_BUS_RELEASE_NUM              0x60
#define EHCI_DS_FRAME_LEN_ADJUST                    0x61
#define EHCI_DS_PORT_WAKE_CAPS                      0x62
#define EHCI_DS_USB_LEGACY_SUP_EXTD                 0x68
#define EHCI_DS_USB_LEGACY_SUP_CTL                  0x6c
#define EHCI_DS_SRAM_DIRECT_ACESS_ADDR              0x70
#define EHCI_DS_DIRECT_ACCESS_CTL                   0x73
#define EHCI_DS_DIRECT_ACCESS_DATA                  0x74
#define EHCI_DS_POWER_MGMT_CAPS                     0x80
#define EHCI_DS_POWER_MGMT_CAPS_STATS               0x84



/* defined for easier port from NetBSD/FreeBSD */

#ifdef _SGIO2_
 #define EREAD1(sc, a)                               pciio_pio_read8(  (uint8_t *)  ((sc)->pci_io_caps) + a )
 #define EREAD2(sc, a)                               pciio_pio_read16( (uint16_t *) ((sc)->pci_io_caps) + (a>>1) )
 #define EREAD4(sc, a)                               pciio_pio_read32( (uint32_t *) ((sc)->pci_io_caps) + (a>>2) )
 #define EWRITE1(sc, a, x)                           pciio_pio_write8(  x, (uint8_t *)  ((sc)->pci_io_caps) + a  )
 #define EWRITE2(sc, a, x)                           pciio_pio_write16( x, (uint16_t *) ((sc)->pci_io_caps) + (a>>1)  )
 #define EWRITE4(sc, a, x)                           pciio_pio_write32( x, (uint32_t *) ((sc)->pci_io_caps) + (a>>2)  )
 #define EOREAD1(sc, a)                              pciio_pio_read8(   (uint8_t *)  ((sc)->pci_io_caps) + a + (sc)->sc_offs )
 #define EOREAD2(sc, a)                              pciio_pio_read16( (uint16_t *)  ((sc)->pci_io_caps) + ((a + (sc)->sc_offs) >> 1) )
 #define EOREAD4(sc, a)                              pciio_pio_read32( (uint32_t *)  ((sc)->pci_io_caps) + ((a + (sc)->sc_offs) >> 2) )
 #define EOWRITE1(sc, a, x)                          pciio_pio_write8(  x, (uint8_t *)  ((sc)->pci_io_caps) + a + (sc)->sc_offs )
 #define EOWRITE2(sc, a, x)                          pciio_pio_write16( x, (uint16_t *) ((sc)->pci_io_caps) + ((a + (sc)->sc_offs)>>1) )
 #define EOWRITE4(sc, a, x)                          pciio_pio_write32( x, (uint32_t *) ((sc)->pci_io_caps) + ((a + (sc)->sc_offs)>>2) )
#else
 #define EREAD1(sc, a)                               ( (uint8_t )   *(  ((sc)->pci_io_caps) + a ))
 #define EREAD2(sc, a)                               ( (uint16_t)   *( (uint16_t *) ((sc)->pci_io_caps) + (a>>1) ))
 #define EREAD4(sc, a)                               ( (uint32_t)   *( (uint32_t *) ((sc)->pci_io_caps) + (a>>2) ))
 #define EWRITE1(sc, a, x)                           ( *(    (uint8_t  *)  ((sc)->pci_io_caps) + a       ) = x)
 #define EWRITE2(sc, a, x)                           ( *(    (uint16_t *)  ((sc)->pci_io_caps) + (a>>1)  ) = x)
 #define EWRITE4(sc, a, x)                           ( *(    (uint32_t *)  ((sc)->pci_io_caps) + (a>>2)  ) = x)
 #define EOREAD1(sc, a)                              ( (uint8_t )   *(  ((sc)->pci_io_caps) + a + (sc)->sc_offs ))
 #define EOREAD2(sc, a)                              ( (uint16_t )  *( (uint16_t *) ((sc)->pci_io_caps) + ((a + (sc)->sc_offs)>>1) ))   
 #define EOREAD4(sc, a)                              ( (uint32_t)   *( (uint32_t *) ((sc)->pci_io_caps) + ((a + (sc)->sc_offs)>>2) ))   
 #define EOWRITE1(sc, a, x)                          ( *(    (uint8_t  *)  ((sc)->pci_io_caps) + a + (sc)->sc_offs ) = x) 
 #define EOWRITE2(sc, a, x)                          ( *(    (uint16_t *)  ((sc)->pci_io_caps) + ((a + (sc)->sc_offs)>>1) ) = x)
 #define EOWRITE4(sc, a, x)                          ( *(    (uint32_t *)  ((sc)->pci_io_caps) + ((a + (sc)->sc_offs)>>2) ) = x)
#endif
#define EHCI_NUM_CONF_REGISTERS                     0x88
#define EHCI_NUM_IO_REGISTERS                       0xc0


#define __FUNCTION__                                __func__

#define TRACE( level,fmt,...)                       if( level <= global_debug_level) printf( "EHCI:%s:%s():%d,"fmt"\r\n", __FILE__, __FUNCTION__, __LINE__, __VA_ARGS__)



/***************************************************************************
 *   Specific driver flags building configuration                          *
 ***************************************************************************/
int         pciehci_devflag = D_MP;
int         pciehci_inuse = 0;     /* number of "pciehci" devices open */
char        *pciehci_mversion = M_VERSION;  /* for loadable modules */


/***************************************************************************
 *   EHCI Specific structures/data                                         *
 ***************************************************************************/


typedef __uint32_t                                             pciehci_reg_t;
typedef volatile struct pciehci_regs_s                         *pciehci_regs_t;  /* dev registers */
typedef struct pciehci_soft_s                                  *pciehci_soft_t;         /* software state */


/*
 *    pciehci_regs: layout of device registers
 *      Our device config registers are, of course, at
 *      the base of our assigned CFG space.
 *      Our device registers are in the PCI area
 *      decoded by the device's first BASE_ADDR window.
 */
struct pciehci_regs_s {
    pciehci_reg_t             pr_control;
    pciehci_reg_t             pr_status;
};

struct pciehci_soft_s {
    HCI_COMMON_DATA
    uchar_t                       *pci_io_caps; /* pointer to mmaped registers */

    uint32_t                      sc_terminate_self;/* TD short packet termination pointer */
    uint32_t                      sc_eintrs;
    uint32_t                      sc_cmd;/* shadow of cmd register during suspend */
    uint16_t                      sc_intr_stat[8];
    uint16_t                      sc_flags;/* chip specific flags */
    #define EHCI_SCFLG_SETMODE      0x0001/* set bridge mode again after init */
    #define EHCI_SCFLG_FORCESPEED   0x0002/* force speed */
    #define EHCI_SCFLG_NORESTERM    0x0004/* don't terminate reset sequence */
    #define EHCI_SCFLG_BIGEDESC     0x0008/* big-endian byte order descriptors */
    #define EHCI_SCFLG_BIGEMMIO     0x0010/* big-endian byte order MMIO */
    #define EHCI_SCFLG_TT           0x0020/* transaction translator present */
    #define EHCI_SCFLG_LOSTINTRBUG  0x0040/* workaround for VIA / ATI chipsets */
    #define EHCI_SCFLG_IAADBUG      0x0080/* workaround for nVidia chipsets */

    uint8_t                       sc_offs; /* offset to operational registers */
    uint8_t                       sc_doorbell_disable;/* set on doorbell failure */
    uint8_t                       sc_noport;
    uint8_t                       sc_addr;/* device address */
    uint8_t                       sc_conf;/* device configuration */
    uint8_t                       sc_isreset;
    uint8_t                       sc_hub_idata[8];
    toid_t                        timeout_value;
};


typedef struct{
    /* device mapped io registers */
    uchar_t                       caps_register_len;
    uchar_t                       reserved0;
    __uint16_t                    interface_version;
    __uint32_t                    structure_params;
    __uint32_t                    caps_params;
    __uint32_t                    reserved1;
    /* memory mapped io registers */
    __uint32_t                    usb_command;
    __uint32_t                    usb_status;
    __uint32_t                    usb_interrupt_enable;
    __uint32_t                    usb_frame_index;
    __uint32_t                    segment_select_4gig;
    __uint32_t                    frame_list_base_addr;
    __uint32_t                    next_async_list_addr;
    __uint32_t                    configured_flag;
    __uint32_t                    port1_sc;
    __uint32_t                    port2_sc;
    __uint32_t                    port3_sc;
    __uint32_t                    port4_sc;
}ehci_mmap_registers_t;


static struct{
    __uint32_t       device_id;
    uchar_t          *controller_description;
}ehci_descriptions[]={
    0x268c8086, "Intel 63XXESB USB 2.0 controller",
    0x523910b9, "ALi M5239 USB 2.0 controller",
    0x10227463, "AMD 8111 USB 2.0 controller",
    0x20951022, "(AMD CS5536 Geode) USB 2.0 controller",
    0x43451002, "ATI SB200 USB 2.0 controller",
    0x43731002, "ATI SB400 USB 2.0 controller",
    0x25ad8086, "Intel 6300ESB USB 2.0 controller",
    0x24cd8086, "(Intel 82801DB/L/M ICH4) USB 2.0 controller",
    0x24dd8086, "(Intel 82801EB/R ICH5) USB 2.0 controller",
    0x265c8086, "(Intel 82801FB ICH6) USB 2.0 controller",
    0x27cc8086, "(Intel 82801GB/R ICH7) USB 2.0 controller",
    0x28368086, "(Intel 82801H ICH8) USB 2.0 controller USB2-A",
    0x283a8086, "(Intel 82801H ICH8) USB 2.0 controller USB2-B",
    0x293a8086, "(Intel 82801I ICH9) USB 2.0 controller",
    0x293c8086, "(Intel 82801I ICH9) USB 2.0 controller",
    0x3a3a8086, "(Intel 82801JI ICH10) USB 2.0 controller USB-A",
    0x3a3c8086, "(Intel 82801JI ICH10) USB 2.0 controller USB-B",
    0x3b348086, "Intel PCH USB 2.0 controller USB-A",
    0x3b3c8086, "Intel PCH USB 2.0 controller USB-B",
    0x00e01033, "NEC uPD 720100 USB 2.0 controller",
    0x006810de, "NVIDIA nForce2 USB 2.0 controller",
    0x008810de, "NVIDIA nForce2 Ultra 400 USB 2.0 controller",
    0x00d810de, "NVIDIA nForce3 USB 2.0 controller",
    0x00e810de, "NVIDIA nForce3 250 USB 2.0 controller",
    0x005b10de, "NVIDIA nForce4 USB 2.0 controller",
    0x036d10de, "NVIDIA nForce MCP55 USB 2.0 controller",
    0x03f210de, "NVIDIA nForce MCP61 USB 2.0 controller",
    0x0aa610de, "NVIDIA nForce MCP79 USB 2.0 controller",
    0x0aa910de, "NVIDIA nForce MCP79 USB 2.0 controller",
    0x0aaa10de, "NVIDIA nForce MCP79 USB 2.0 controller",
    0x15621131, "Philips ISP156x USB 2.0 controller",
    0x31041106, "VIA VT6212 EHCI USB 2.0 controller",
    0 ,NULL
};


/***************************************************************************
 *   Function table of contents                                            *
 ***************************************************************************/
void                    pciehci_init(void);
int                     pciehci_unload(void);
int                     pciehci_reg(void);
int                     pciehci_unreg(void);
int                     pciehci_attach(vertex_hdl_t conn);
int                     pciehci_detach(vertex_hdl_t conn);
static pciio_iter_f     pciehci_reloadme;
static pciio_iter_f     pciehci_unloadme;
int                     pciehci_open(dev_t *devp, int oflag, int otyp, cred_t *crp);
int                     pciehci_close(dev_t dev, int oflag, int otyp, cred_t *crp);
int                     pciehci_ioctl(dev_t dev, int cmd, void *arg, int mode, cred_t *crp, int *rvalp);
int                     pciehci_read(dev_t dev, uio_t * uiop, cred_t *crp);
int                     pciehci_write(dev_t dev, uio_t * uiop,cred_t *crp);
int                     pciehci_strategy(struct buf *bp);
int                     pciehci_poll(dev_t dev, short events, int anyyet, short *reventsp, struct pollhead **phpp, unsigned int *genp);
int                     pciehci_map(dev_t dev, vhandl_t *vt, off_t off, size_t len, uint_t prot);
int                     pciehci_unmap(dev_t dev, vhandl_t *vt);
void                    pciehci_dma_intr(intr_arg_t arg);
static error_handler_f  pciehci_error_handler;
void                    pciehci_halt(void);
int                     pciehci_size(dev_t dev);
int                     pciehci_print(dev_t dev, char *str);

pciehci_soft_t          global_soft;
/*uint32_t                global_debug_level = PCIEHCI_DEBUG_ALL;*/
uint32_t                global_ports_status[EHCI_MAX_NUM_PORTS]; 
uchar_t                 global_num_ports;
uint32_t                global_debug_level = 0;

/***************************************************************************
 *   EHCI functions                                                        *
 ***************************************************************************/
void ehci_reset(pciehci_soft_t sc){
    uint32_t hcr;
    int i;

    EOWRITE4(sc, EHCI_USBCMD, EHCI_CMD_HCRESET);
    for (i = 0; i < 50; i++) {
        USECDELAY(100000);
        hcr = EOREAD4(sc, EHCI_USBCMD) & EHCI_CMD_HCRESET;
        if (!hcr) {
            if (sc->sc_flags & (EHCI_SCFLG_SETMODE | EHCI_SCFLG_BIGEMMIO)) {
            /*
             * Force USBMODE as requested.  Controllers
             * may have multiple operating modes.
             */
                uint32_t usbmode = EOREAD4(sc, EHCI_USBMODE);
                if (sc->sc_flags & EHCI_SCFLG_SETMODE) {
                    usbmode = (usbmode &~ EHCI_UM_CM) | EHCI_UM_CM_HOST;
                    printf( "set host controller mode\n");
                }

                if (sc->sc_flags & EHCI_SCFLG_BIGEMMIO) {
                    usbmode = (usbmode &~ EHCI_UM_ES) | EHCI_UM_ES_BE;
                    printf( "set big-endian mode\n");
                }
                EOWRITE4(sc,  EHCI_USBMODE, usbmode);
            }
            return;
        }
    }
    printf("reset timeout\n");
}


void ehci_hcreset(pciehci_soft_t sc){
    uint32_t hcr;
    int i;

    EOWRITE4(sc, EHCI_USBCMD, 0);/* Halt controller */
    for (i = 0; i < 100; i++) {
        USECDELAY(100000);
        hcr = EOREAD4(sc, EHCI_USBSTS) & EHCI_STS_HCH;
        if (hcr)
            break;
    }

    if (!hcr)
        /*
         * Fall through and try reset anyway even though
         * Table 2-9 in the EHCI spec says this will result
         * in undefined behavior.
         */
        printf("stop timeout\n");

    ehci_reset(sc);
}


void ehci_init(pciehci_soft_t sc){
    uint32_t version;
    uint32_t sparams;
    uint32_t cparams;
    uint32_t hcr;
    uint16_t i;
    uint32_t cmd;
	int n;

    printf("ehci_init()\n");
    printf("sc = %x\n", sc);

    sc->sc_offs = EHCI_CAPLENGTH(EREAD4(sc, EHCI_CAPLEN_HCIVERSION));
    printf( "sc_offs=0x%x\n", sc->sc_offs);

    sc->ps_event = 0x0000;


    version = EHCI_HCIVERSION(EREAD4(sc, EHCI_CAPLEN_HCIVERSION));
    printf( "EHCI version %x.%x\n", version >> 8, version & 0xff);
    USECDELAY(100000);
    sparams = EREAD4(sc, EHCI_HCSPARAMS);
    printf("sparams=0x%x\n", sparams);
    USECDELAY(100000);
    USECDELAY(100000);    
    sc->sc_noport = EHCI_HCS_N_PORTS(sparams);
	printf("ports number=%d\n", sc->sc_noport);
	global_num_ports = sc->sc_noport;

    USECDELAY(100000);
    USECDELAY(100000);    
    cparams = EREAD4(sc, EHCI_HCCPARAMS);
    printf("cparams=0x%x\n", cparams);
    USECDELAY(100000);
    USECDELAY(100000);

    if (EHCI_HCC_64BIT(cparams)) {
        printf("HCC uses 64-bit structures\n");
        USECDELAY(100000);
        /* MUST clear segment register if 64 bit capable */
        EWRITE4(sc, EHCI_CTRLDSSEGMENT, 0);
    }

    /* Reset the controller */
    printf("EHCI controller resetting\n");
    USECDELAY(100000);
    USECDELAY(100000);    
    /*        ehci_hcreset(sc);*/

    /*
     * use current frame-list-size selection 0: 1024*4 bytes 1:  512*4
     * bytes 2:  256*4 bytes 3:      unknown
     */
    USECDELAY(100000);

    if (EHCI_CMD_FLS(EOREAD4(sc, EHCI_USBCMD)) == 3) {
        printf("invalid frame-list-size\n");
    }

    USECDELAY(100000);
    USECDELAY(100000);
    printf("Turn on controller\n");
    /* turn on controller */
    /* as the PCI bus in the O2 is too slow (33 mhz). we need to slowdown the interrupts max rate to 64 microframes (8 ms).
       default is 1 microframe (0x08)
	*/

    USECDELAY(100000);
    USECDELAY(100000);    
    USECDELAY(100000);    
    USECDELAY(100000);    
    
    EOWRITE4(sc, EHCI_USBCMD,
                 EHCI_CMD_ITC_64 | /* 1 microframes interrupt delay */
                (EOREAD4(sc, EHCI_USBCMD) & EHCI_CMD_FLS_M) |
                 EHCI_CMD_ASE |
                 EHCI_CMD_PSE |
                 EHCI_CMD_RS);

    printf("no trono\n");

    USECDELAY(100000);    
    USECDELAY(100000);    
    USECDELAY(100000);    
    USECDELAY(100000);
    printf("Enable interrupts\n");
    /* enable interrupts */
    sc->sc_eintrs = EHCI_NORMAL_INTRS;
    EOWRITE4(sc, EHCI_USBINTR, sc->sc_eintrs);

    USECDELAY(100000);
    USECDELAY(100000);

    /* Take over port ownership */
    printf("EHCI driver now has ports ownership\n");
    EOWRITE4(sc, EHCI_CONFIGFLAG, EHCI_CONF_CF);

/*    for (i = 0; i < 100; i++) {
        USECDELAY(100000);
        hcr = EOREAD4(sc, EHCI_USBSTS) & EHCI_STS_HCH;
        if (!hcr) {
            break;
        }
    }

    if (hcr) {
        printf("run timeout\n");
    }
*/
    /* EHCI take property of all ports first */
    printf("EHCI driver taking property of all ports over another *HCI\n");
    USECDELAY(100000);
    for (i = 1; i <= sc->sc_noport; i++) {
        cmd = EOREAD4(sc, EHCI_PORTSC(i));
        EOWRITE4(sc, EHCI_PORTSC(i), cmd & ~EHCI_PS_PO);
        global_ports_status[i-1] = 0;
    }


    printf("ehci_init() exit\n");
    USECDELAY(100000);
}



/*
 * shut down the controller when the system is going down
 */
void ehci_detach(pciehci_soft_t sc){
    EOWRITE4(sc, EHCI_USBINTR, 0);
    ehci_hcreset(sc);
}

void ehci_suspend(pciehci_soft_t sc){
    uint32_t cmd;
    uint32_t hcr;
    uint8_t i;

    for (i = 1; i <= sc->sc_noport; i++) {
        cmd = EOREAD4(sc, EHCI_PORTSC(i));
        if (((cmd & EHCI_PS_PO) == 0) && ((cmd & EHCI_PS_PE) == EHCI_PS_PE)) {
            EOWRITE4(sc, EHCI_PORTSC(i), cmd | EHCI_PS_SUSP);
        }
    }

    sc->sc_cmd = EOREAD4(sc, EHCI_USBCMD);

    cmd = sc->sc_cmd & ~(EHCI_CMD_ASE | EHCI_CMD_PSE);
    EOWRITE4(sc, EHCI_USBCMD, cmd);

    for (i = 0; i < 100; i++) {
        hcr = EOREAD4(sc, EHCI_USBSTS) & (EHCI_STS_ASS | EHCI_STS_PSS);

        if (hcr == 0) {
            break;
        }
    }

    if (hcr != 0) {
        printf("reset timeout\n");
    }
    cmd &= ~EHCI_CMD_RS;
    EOWRITE4(sc, EHCI_USBCMD, cmd);

    for (i = 0; i < 100; i++) {
        hcr = EOREAD4(sc, EHCI_USBSTS) & EHCI_STS_HCH;
        if (hcr == EHCI_STS_HCH) {
            break;
        }
    }

    if (hcr != EHCI_STS_HCH) {
        printf("config timeout\n");
    }
}




void ehci_resume(pciehci_soft_t sc){
    uint32_t cmd;
    uint32_t hcr;
    uint8_t i;

    /* restore things in case the bios doesn't */
    EOWRITE4(sc, EHCI_CTRLDSSEGMENT, 0);
    EOWRITE4(sc, EHCI_USBINTR, sc->sc_eintrs);

    hcr = 0;
    for (i = 1; i <= sc->sc_noport; i++) {
        cmd = EOREAD4(sc, EHCI_PORTSC(i));
        if (((cmd & EHCI_PS_PO) == 0) && ((cmd & EHCI_PS_SUSP) == EHCI_PS_SUSP)) {
            EOWRITE4(sc, EHCI_PORTSC(i), cmd | EHCI_PS_FPR);
            hcr = 1;
        }
    }

    if (hcr) {
        for (i = 1; i <= sc->sc_noport; i++) {
            cmd = EOREAD4(sc, EHCI_PORTSC(i));
            if (((cmd & EHCI_PS_PO) == 0) && ((cmd & EHCI_PS_SUSP) == EHCI_PS_SUSP)) {
                EOWRITE4(sc, EHCI_PORTSC(i), cmd & ~EHCI_PS_FPR);
            }
        }
    }
    EOWRITE4(sc, EHCI_USBCMD, sc->sc_cmd);

    for (i = 0; i < 100; i++) {
        hcr = EOREAD4(sc, EHCI_USBSTS) & EHCI_STS_HCH;
        if (hcr != EHCI_STS_HCH) {
            break;
        }
    }
    if (hcr == EHCI_STS_HCH) {
        printf( "config timeout\n");
    }


}

void ehci_shutdown(pciehci_soft_t sc){
    printf("stopping the HC\n");
    ehci_hcreset(sc);
}

void ehci_dump_regs(pciehci_soft_t sc){
    uint32_t i;

    i = EOREAD4(sc, EHCI_USBCMD);
    printf("cmd=0x%08x\n", i);

    if (i & EHCI_CMD_ITC_1)
	    printf(" EHCI_CMD_ITC_1\n");
    if (i & EHCI_CMD_ITC_2)
        printf(" EHCI_CMD_ITC_2\n");
    if (i & EHCI_CMD_ITC_4)
        printf(" EHCI_CMD_ITC_4\n");
    if (i & EHCI_CMD_ITC_8)
        printf(" EHCI_CMD_ITC_8\n");
    if (i & EHCI_CMD_ITC_16)
        printf(" EHCI_CMD_ITC_16\n");
    if (i & EHCI_CMD_ITC_32)
        printf(" EHCI_CMD_ITC_32\n");
    if (i & EHCI_CMD_ITC_64)
        printf(" EHCI_CMD_ITC_64\n");
    if (i & EHCI_CMD_ASPME)
        printf(" EHCI_CMD_ASPME\n");
    if (i & EHCI_CMD_ASPMC)
        printf(" EHCI_CMD_ASPMC\n");
    if (i & EHCI_CMD_LHCR)
        printf(" EHCI_CMD_LHCR\n");
    if (i & EHCI_CMD_IAAD)
        printf(" EHCI_CMD_IAAD\n");
    if (i & EHCI_CMD_ASE)
        printf(" EHCI_CMD_ASE\n");
    if (i & EHCI_CMD_PSE)
        printf(" EHCI_CMD_PSE\n");
    if (i & EHCI_CMD_FLS_M)
        printf(" EHCI_CMD_FLS_M\n");
    if (i & EHCI_CMD_HCRESET)
        printf(" EHCI_CMD_HCRESET\n");
    if (i & EHCI_CMD_RS)
        printf(" EHCI_CMD_RS\n");

    i = EOREAD4(sc, EHCI_USBSTS);

    printf("sts=0x%08x\n", i);

    if (i & EHCI_STS_ASS)
        printf(" EHCI_STS_ASS\n");
    if (i & EHCI_STS_PSS)
        printf(" EHCI_STS_PSS\n");
    if (i & EHCI_STS_REC)
        printf(" EHCI_STS_REC\n");
    if (i & EHCI_STS_HCH)
        printf(" EHCI_STS_HCH\n");
    if (i & EHCI_STS_IAA)
        printf(" EHCI_STS_IAA\n");
    if (i & EHCI_STS_HSE)
        printf(" EHCI_STS_HSE\n");
    if (i & EHCI_STS_FLR)
        printf(" EHCI_STS_FLR\n");
    if (i & EHCI_STS_PCD)
        printf(" EHCI_STS_PCD\n");
    if (i & EHCI_STS_ERRINT)
        printf(" EHCI_STS_ERRINT\n");
    if (i & EHCI_STS_INT)
        printf(" EHCI_STS_INT\n");

    printf("intr=0x%08x\n",
    EOREAD4(sc, EHCI_USBINTR));
    printf("frindex=0x%08x ctrdsegm=0x%08x periodic=0x%08x async=0x%08x\n",
    EOREAD4(sc, EHCI_FRINDEX),
    EOREAD4(sc, EHCI_CTRLDSSEGMENT),
    EOREAD4(sc, EHCI_PERIODICLISTBASE),
    EOREAD4(sc, EHCI_ASYNCLISTADDR));
    for (i = 1; i <= sc->sc_noport; i++) {
        printf("port %d status=0x%08x\n", i,
        EOREAD4(sc, EHCI_PORTSC(i)));
    }
}


/*------------------------------------------------------------------------*
 *ehci_interrupt - EHCI interrupt handler
 *
 * NOTE: Do not access "sc->sc_bus.bdev" inside the interrupt handler,
 * hence the interrupt handler will be setup before "sc->sc_bus.bdev"
 * is present !
 *------------------------------------------------------------------------*/
void ehci_interrupt(pciehci_soft_t sc){
    uint32_t status, port_connect, pr, port_status;
	int i;

    printf("real interrupt()\n");
    printf("sc = %x\n", sc);
    printf("sc->pci_io_caps=0x%x\n", sc->pci_io_caps);

	printf("checking if interrupt was for us\n");
    status = EHCI_STS_INTRS(EOREAD4(sc, EHCI_USBSTS));
    if (status == 0) {
        /* the interrupt was not for us */
        return;
    }

    
    
    if (!(status & sc->sc_eintrs)) {
        return;
    }

	
    printf("ack\n");
    EOWRITE4(sc, EHCI_USBSTS, status);/* acknowledge */

    status &= sc->sc_eintrs;

	printf("ok00\n");
    if (status & EHCI_STS_HSE) {
        printf("unrecoverable error, controller halted\n");
        ehci_dump_regs(sc);
    }

    if( status & EHCI_STS_PCD){
        printf("port change detected!\n");
	for (i = 1; i <= sc->sc_noport; i++){
	    port_status = EOREAD4(sc, EHCI_PORTSC(i));
	    printf("port %d = 0x%x\n", i, port_status);
	    port_connect = port_status & EHCI_PS_CLEAR;

            sc->ps_event |= EHCI_EVENT_PORT_ACTIVITY;

	    /* pick out CHANGE bits from the status register */
	    if( port_connect){
                printf("activity in port %d\n", i);
	        if( (port_status & EHCI_PS_CS) == 0){
	            printf("Device disconnected\n");
                    sc->ps_event |= EHCI_EVENT_PORT_DISCONNECT;
                    global_ports_status[i-1] = 0;
                }else{
                    printf("Device connected\n");
                    sc->ps_event |= EHCI_EVENT_PORT_CONNECT;
	            global_ports_status[i-1] = 1;
	            if( EHCI_PS_IS_LOWSPEED(EOREAD4(sc, EHCI_PORTSC(i)))){
	                printf("No High speed device, passing to companion controller\n");
                    }else{
  		        printf("Device is High speed, resetting\n");
	                /*printf("   -Sending HCHalt\n");
	                ehci_hcreset(sc);*/
	                printf("   -Port reset\n");
                        EOWRITE4( sc, EHCI_PORTSC(i),  EOREAD4(sc, EHCI_PORTSC(i)) | EHCI_PS_PR | EHCI_PS_CSC);
                        for (i = 0; i < 100; i++) {
                            USECDELAY(100);
                            pr = EOREAD4(sc, EHCI_PORTSC(i)) & EHCI_PS_PR;
                            if (!pr)
                                break;
                     
		        }            
		    }
	        }
	        EOWRITE4( sc, EHCI_PORTSC(i),  EOREAD4(sc, EHCI_PORTSC(i)) | EHCI_PS_CSC);
                
	    }
        }
    }	
	
       
    printf("sc->ps_event=0x%x, pciehci_inuse=%d\n", sc->ps_event, pciehci_inuse);    
    if( sc->ps_event != 0 && pciehci_inuse != 0){
        printf("call pollwakeup()\n");
        printf("pollhead=0x%x, global_pollhead=0x%x\n", sc->ps_pollhead, global_soft->ps_pollhead );
        pollwakeup( sc->ps_pollhead, POLLIN);
    }
    /*if (status & EHCI_STS_PCD) {*/
        /*
         * Disable PCD interrupt for now, because it will be
         * on until the port has been reset.
         */
/*        sc->sc_eintrs &= ~EHCI_STS_PCD;
        EOWRITE4(sc, EHCI_USBINTR, sc->sc_eintrs);*/
    /*}*/


    status &= ~(EHCI_STS_INT | EHCI_STS_ERRINT | EHCI_STS_PCD | EHCI_STS_IAA);

    if (status != 0) {
        /* block unprocessed interrupts */
/*        sc->sc_eintrs &= ~status;*/
        printf("ok02\n");
/*
        EOWRITE4(sc, EHCI_USBINTR, sc->sc_eintrs);
        printf("blocking interrupts 0x%x\n",  status);*/
    }
    
    
}

void ehci_takecontroller(pciehci_soft_t sc){
    uint32_t cparams;
    uint32_t eec;
    uint16_t to;
    uint8_t eecp;
    uint8_t bios_sem;

    printf("ehci_pci_takecontroller()\n");
    printf("Take controller1: reading HCCPARAMS: 0x%x\n", EHCI_HCCPARAMS);
    USECDELAY(100000);

    cparams = EREAD4(sc, EHCI_HCCPARAMS);
    printf( "cparams = %d\n", cparams);
    /* Synchronise with the BIOS if it owns the controller. */
    for (eecp = EHCI_HCC_EECP(cparams); eecp != 0; eecp = EHCI_EECP_NEXT(eec)) {
        eec = pci_read_config(sc->ps_conn, eecp, 4);
        if (EHCI_EECP_ID(eec) != EHCI_EC_LEGSUP) {
            continue;
        }
        bios_sem = pci_read_config(sc->ps_conn, eecp + EHCI_LEGSUP_BIOS_SEM, 1);
        if (bios_sem == 0) {
            continue;
        }
        printf( "waiting for BIOS to give up control\n");
        pci_write_config(sc->ps_conn, eecp + EHCI_LEGSUP_OS_SEM, 1, 1);
        to = 500;
        while (1) {
            bios_sem = pci_read_config(sc->ps_conn, eecp + EHCI_LEGSUP_BIOS_SEM, 1);
            USECDELAY(100000);
            if (bios_sem == 0)
                break;

            if (--to == 0) {
                printf("timed out waiting for BIOS\n");
                break;
            }
        }
    }
    printf("ehci_pci_takecontroller() exit\n");

}



/***************************************************************************
 *   Driver specific entry-point functions                                 *
 ***************************************************************************/

/*
 *    pciehci_init: called once during system startup or
 *      when a loadable driver is loaded.
 */
void pciehci_init(void){
    printf("pciehci_init()\n");
    printf("**********************************************************\n");
    printf("* EHCI USB Driver for Silicon Graphics Irix 6.5          *\n");
    printf("* By bsdero at gmail dot org, 2011                       *\n");
    printf("* Version 0.0.1                                          *\n");
    printf("**********************************************************\n");
    printf("EHCI Driver loaded!!\n");

    /*
     * if we are already registered, note that this is a
     * "reload" and reconnect all the places we attached.
     */
    USECDELAY(100000);
    pciio_iterate("pciehci_", pciehci_reloadme);
}


/*
 *    pciehci_unload: if no "pciehci" is open, put us to bed
 *      and let the driver text get unloaded.
 */
int pciehci_unload(void){
    if (pciehci_inuse)
        return EBUSY;
    pciio_iterate("pciehci_", pciehci_unloadme);
    return 0;
}


/*
 *    pciehci_reg: called once during system startup or
 *      when a loadable driver is loaded.
 *    NOTE: a bus provider register routine should always be
 *      called from _reg, rather than from _init. In the case
 *      of a loadable module, the devsw is not hooked up
 *      when the _init routines are called.
 */
int pciehci_reg(void){
    uint16_t device_id, vendor_id;
    uchar_t *device_description;
    int i;

    printf("pciehci_reg()\n");

    /* registering EHCI devices */
    printf("  -registering EHCI devices\n");
    for( i = 0; ehci_descriptions[i].device_id != 0; i++){
        device_id = ((ehci_descriptions[i].device_id & 0xffff0000) >> 16);
        vendor_id = (ehci_descriptions[i].device_id & 0x0000ffff);
        pciio_driver_register(vendor_id, device_id, "pciehci_", 0);  /* pciehci_attach and pciehci_detach entry points */
    }

    return 0;
}

/*
 *    pciehci_unreg: called when a loadable driver is unloaded.
 */
int pciehci_unreg(void){
    pciio_driver_unregister("pciehci_");
    return 0;
}


/*
 *    pciehci_attach: called by the pciio infrastructure
 *      once for each vertex representing a crosstalk widget.
 *      In large configurations, it is possible for a
 *      huge number of CPUs to enter this routine all at
 *      nearly the same time, for different specific
 *      instances of the device. Attempting to give your
 *      devices sequence numbers based on the order they
 *      are found in the system is not only futile but may be
 *      dangerous as the order may differ from run to run.
 */
int pciehci_attach(vertex_hdl_t conn){
    vertex_hdl_t            vhdl, blockv, charv;
    volatile uchar_t        *cfg;
    pciehci_soft_t          soft;
	pciehci_regs_t          regs;
    __uint16_t              vendor_id;
    __uint16_t              device_id;
    __uint32_t              ssid;
    uchar_t                 rev_id;
    device_desc_t           pciehci_dev_desc;
    ehci_mmap_registers_t   *registers;
    __uint32_t              val;
    pciio_piomap_t          rmap = 0;
    pciio_piomap_t          cmap = 0;
    int                     i, retcode;
    uint32_t                device_vendor_id;
    int x, *m;

    printf("pciehci_attach()\n");
    TRACE( 0, "TEST TRACE", "");
    USECDELAY(100000);
    hwgraph_device_add(conn,"pciehci","pciehci_",&vhdl,&blockv,&charv);
    /*
     * Allocate a place to put per-device information for this vertex.
     * Then associate it with the vertex in the most efficient manner.
     */
    NEW(soft);
    ASSERT(soft != NULL);


    hci_soft_set(vhdl, soft);
    hci_soft_set(blockv, soft);
    hci_soft_set(charv, soft);
    soft->ps_conn = conn;
    soft->ps_vhdl = vhdl;
    soft->ps_blockv = blockv;
    soft->ps_charv = charv;

    pciehci_dev_desc = device_desc_dup(vhdl);
    device_desc_intr_name_set(pciehci_dev_desc, "pciehci");
    device_desc_default_set(vhdl, pciehci_dev_desc);
    /*
     * Find our PCI CONFIG registers.
     */
    cfg = (volatile uchar_t *) pciio_pio_addr
        (conn, 0,                     /* device and (override) dev_info */
         PCIIO_SPACE_CFG,             /* select configuration addr space */
         0,                           /* from the start of space, */
         EHCI_NUM_CONF_REGISTERS,     /* ... up to vendor specific stuff */
         &cmap,                       /* in case we needed a piomap */
         0);                          /* flag word */
    soft->ps_cfg = *cfg;              /* save for later */
    soft->ps_cmap = cmap;
    printf("ok 1");
    USECDELAY(1000); 
    vendor_id = PCI_CFG_GET16(conn, EHCI_CF_VENDOR_ID);
    device_id = PCI_CFG_GET16(conn, EHCI_CF_DEVICE_ID);
    ssid = PCI_CFG_GET32( conn, EHCI_CF_SSID);
    rev_id = PCI_CFG_GET8( conn, EHCI_CF_REVISION_ID);

    printf( "EHCI supported device found\n");
    printf( "Vendor ID: 0x%x\nDevice ID: 0x%x\n", vendor_id, device_id);
    USECDELAY(1000);
    device_vendor_id = device_id << 16 | vendor_id;
    for( i = 0; ehci_descriptions[i].device_id != 0; i++){
        if( ehci_descriptions[i].device_id == device_vendor_id){
		    soft->controller_desc.device_type = PCIEHCI_DEV;
			soft->controller_desc.vendor_id = vendor_id;
			soft->controller_desc.device_id = device_id;
			strcpy( soft->controller_desc.description, ehci_descriptions[i].controller_description);
            printf("Device Description: %s\n", ehci_descriptions[i].controller_description);
            break;
        }
    }
    dumphex( soft->controller_desc.description, strlen( soft->controller_desc.description));
    printf( "SSID: 0x%x\nRevision ID: 0x%x\n", ssid, rev_id);



    /*
     * Get a pointer to our DEVICE registers
     */
    regs = (pciehci_regs_t) pciio_pio_addr
        (conn, 0,                       /* device and (override) dev_info */
         PCIIO_SPACE_WIN(0),            /* in my primary decode window, */
         0, EHCI_NUM_IO_REGISTERS,      /* base and size */
         &rmap,                         /* in case we needed a piomap */
         0);                            /* flag word */
    soft->ps_regs = regs;               /* save for later */
    soft->ps_rmap = rmap;
    cfg = (uchar_t *) regs;


    switch (pci_read_config(conn, PCI_USBREV, 1) & PCI_USB_REV_MASK) {
        case PCI_USB_REV_PRE_1_0:
        case PCI_USB_REV_1_0:
        case PCI_USB_REV_1_1:
            /*
             * NOTE: some EHCI USB controllers have the wrong USB
             * revision number. It appears those controllers are
             * fully compliant so we just ignore this value in
             * some common cases.
             */
            printf( "pre-2.0 USB revision (ignored)\n");
            /* fallthrough */
			break;
        case PCI_USB_REV_2_0:
		    printf( "USB 2.0 revision\n");
        break;
        default:
            /* Quirk for Parallels Desktop 4.0 */
            printf("USB revision is unknown. Assuming v2.0.\n");
        break;
    }

    soft->pci_io_caps = (uchar_t *) cfg;
    registers = (ehci_mmap_registers_t *) cfg;
	printf("EHCI preconfiguration registers-dump\n");
	ehci_dump_regs( soft);
	printf("\n");


    if ((device_id == 0x3104 || device_id == 0x3038) &&
	 (rev_id & 0xf0) == 0x60){

        /* Correct schedule sleep time to 10us */
        val = pci_read_config(conn, EHCI_DS_MAX_TURN_AROUND_TIME, 1);
        if ( !(val & 0x20))
            pci_write_config(conn, EHCI_DS_MAX_TURN_AROUND_TIME, val, 1);
            printf("VIA-quirk applied\n");
        }

	soft->sc_flags = 0;
    if( vendor_id == 0x1002 || vendor_id == 0x1106){
        soft->sc_flags |= EHCI_SCFLG_LOSTINTRBUG;
        printf( "Dropped interrupts workaround enabled\n");
    }

    printf("Init soft=0x%x, soft->pci_io_caps=0x%x\n", soft, soft->pci_io_caps);
    for( i = 0; i < 13; i++)
       printf("EHCIMAP8 i= %d:%x\n", i, EREAD1(soft, i));
    for( i = 0; i < 13; i+=2)
       printf("EHCIMAP16 i= %d:%x\n", i, EREAD2(soft, i));
    for( i = 0; i < 13; i+=4)
       printf("EHCIMAP32 i= %d:%x\n", i, EREAD4(soft, i));
       
    gc_list_init( &soft->gc_list);
    for( x = 0;x < 5; x++){
        m = (int *)gc_malloc( &soft->gc_list, sizeof(int));
        *m = x;
    }
    gc_list_dump( &soft->gc_list);
    
    printf("Starting with DMA\n");   
    dma_list_init( &soft->dma_list);
    dma_alloc( charv, &soft->dma_list, 64, 0);
    
    
    ehci_init(soft);
/*
    printf("Take controller\n");
    ehci_pci_takecontroller(soft);
    USECDELAY(100000);
	*/
    /*
     * Set up our interrupt.
     * We might interrupt on INTA or INTB,
     * but route 'em both to the same function.
     */
     
     
    printf("Creating PCI INTR\n");
    soft->ps_intr = pciio_intr_alloc
        (conn, pciehci_dev_desc,
         PCIIO_INTR_LINE_C,   /* VIA EHCI works with line C only */
         vhdl);

    printf("about to connect..\n");
	global_soft = soft;
    retcode = pciio_intr_connect(soft->ps_intr, pciehci_dma_intr, soft,(void *) 0);

    printf("retcode = %d\n", retcode);

    /*
     * set up our error handler.
     */
    pciio_error_register(conn, pciehci_error_handler, soft);
    /*
     * For pciio clients, *now* is the time to
     * allocate pollhead structures.
     */
    soft->ps_pollhead = phalloc(KM_SLEEP);
    soft->ps_ctl_dmamap = NULL;
    printf("pollhead=0x%x\n", soft->ps_pollhead);
    return 0;                      /* attach successsful */
}


/*
 *    pciehci_detach: called by the pciio infrastructure
 *      once for each vertex representing a crosstalk
 *      widget when unregistering the driver.
 *
 *      In large configurations, it is possible for a
 *      huge number of CPUs to enter this routine all at
 *      nearly the same time, for different specific
 *      instances of the device. Attempting to give your
 *      devices sequence numbers based on the order they
 *      are found in the system is not only futile but may be
 *      dangerous as the order may differ from run to run.
 */
int pciehci_detach(vertex_hdl_t conn)
{
    vertex_hdl_t            vhdl, blockv, charv;
    pciehci_soft_t            soft;
    printf("pciehci_detach()\n");

    if (GRAPH_SUCCESS !=
        hwgraph_traverse(conn, "pciehci", &vhdl))
        return -1;
    soft = (pciehci_soft_t)device_info_get(vhdl);
    printf(" ok ");
    pciio_error_register(conn, 0, 0);

    printf(" 1");
    pciio_intr_disconnect(soft->ps_intr);
/*
    printf(" 1.5");
    untimeout( soft->timeout_value);
*/
    printf(" 2");
    pciio_intr_free(soft->ps_intr);

    printf(" 3");
    phfree(soft->ps_pollhead);
    printf(" 4");
    gc_list_dump( &soft->gc_list);
    gc_list_destroy( &soft->gc_list);
    dma_list_destroy( &soft->dma_list);
/*    if (soft->ps_ctl_dmamap)
        pciio_dmamap_free(soft->ps_ctl_dmamap);
        
    if (soft->ps_str_dmamap)
        pciio_dmamap_free(soft->ps_str_dmamap);


    if (soft->ps_cmap)
        pciio_piomap_free(soft->ps_cmap);
*/
        
    printf(" 5");
    if (soft->ps_rmap)
        pciio_piomap_free(soft->ps_rmap);
    printf(" 6");
    hwgraph_edge_remove(conn, "pciehci", &vhdl);
    /*
     * we really need "hwgraph_dev_remove" ...
     */
    printf(" 7");
    if (GRAPH_SUCCESS ==
        hwgraph_edge_remove(vhdl, EDGE_LBL_BLOCK, &blockv)) {
        hci_soft_set(blockv, 0);
        hwgraph_vertex_destroy(blockv);
    }
    printf(" 8");
    if (GRAPH_SUCCESS ==
        hwgraph_edge_remove(vhdl, EDGE_LBL_CHAR, &charv)) {
        hci_soft_set(charv, 0);
        hwgraph_vertex_destroy(charv);
    }
    hci_soft_set(vhdl, 0);
    hwgraph_vertex_destroy(vhdl);
    DEL(soft);
    return 0;
}

/*
 *    pciehci_reloadme: utility function used indirectly
 *      by pciehci_init, via pciio_iterate, to "reconnect"
 *      each connection point when the driver has been
 *      reloaded.
 */
static void
pciehci_reloadme(vertex_hdl_t conn)
{
    vertex_hdl_t            vhdl;
    pciehci_soft_t            soft;
    if (GRAPH_SUCCESS !=
        hwgraph_traverse(conn, "pciehci", &vhdl))
        return;
    soft = (pciehci_soft_t)device_info_get(vhdl);
    /*
     * Reconnect our error and interrupt handlers
     */
    pciio_error_register(conn, pciehci_error_handler, soft);
    pciio_intr_connect(soft->ps_intr, pciehci_dma_intr, soft, 0);
}
/*
 *    pciehci_unloadme: utility function used indirectly by
 *      pciehci_unload, via pciio_iterate, to "disconnect" each
 *      connection point before the driver becomes unloaded.
 */
static void
pciehci_unloadme(vertex_hdl_t pconn)
{
    vertex_hdl_t            vhdl;
    pciehci_soft_t            soft;
    if (GRAPH_SUCCESS !=
        hwgraph_traverse(pconn, "pciehci", &vhdl))
        return;
    soft = (pciehci_soft_t)device_info_get(vhdl);
    /*
     * Disconnect our error and interrupt handlers
     */
    pciio_error_register(pconn, 0, 0);
    pciio_intr_disconnect(soft->ps_intr);
}
/* ====================================================================
 *          DRIVER OPEN/CLOSE
 */
/*
 *    pciehci_open: called when a device special file is
 *      opened or when a block device is mounted.
 */
/* ARGSUSED */
int pciehci_open(dev_t *devp, int oflag, int otyp, cred_t *crp){
    vertex_hdl_t              vhdl;
	pciehci_soft_t            soft;
	pciehci_regs_t            regs;
	
	printf("pciehci_open()\n");
	if( *devp == NULL){
	    return( EIO); 
	}
	
    vhdl = dev_to_vhdl(*devp);
	soft = (pciehci_soft_t)device_info_get(vhdl);
	
	if( soft == NULL){
	    return( EIO);
	}
	
    regs = soft->ps_regs;
    printf("pciehci_open() regs=%x\n", regs);

    /*
     * BLOCK DEVICES: now would be a good time to
     * calculate the size of the device and stash it
     * away for use by pciehci_size.
     */
    /*
     * USER ABI (64-bit): chances are, you are being
     * compiled for use in a 64-bit IRIX kernel; if
     * you use the _ioctl or _poll entry points, now
     * would be a good time to test and save the
     * user process' model so you know how to
     * interpret the user ioctl and poll requests.
     */
    if (!(DEVICE_SST_INUSE & atomicSetUint(&soft->ps_sst, DEVICE_SST_INUSE))){
        atomicAddInt(&pciehci_inuse, 1);
	return 0;
    }
	
    return EBUSY;
}


/*
 *    pciehci_close: called when a device special file
 *      is closed by a process and no other processes
 *      still have it open ("last close").
 */
/* ARGSUSED */
int pciehci_close(dev_t dev, int oflag, int otyp, cred_t *crp){
    vertex_hdl_t              vhdl;
	pciehci_soft_t            soft;
	pciehci_regs_t            regs;
	
	printf("pciehci_close()\n");
	
    vhdl = dev_to_vhdl(dev);
	soft = (pciehci_soft_t)device_info_get(vhdl);
	
	if( soft == NULL){
	    return( EIO);
	}
	
    regs = soft->ps_regs;
    printf("pciehci_close() regs=%x\n", regs);
    atomicClearUint(&soft->ps_sst, DEVICE_SST_INUSE);
    atomicAddInt(&pciehci_inuse, -1);
    return 0;
}


void ehci_setup_usb_transfer(dev_t dev){
      vertex_hdl_t vhdl = dev_to_vhdl(dev);
      pciehci_soft_t          soft = (pciehci_soft_t)device_info_get(vhdl);
      
      
      soft->ps_ctl_dmamap = pciio_dmamap_alloc(vhdl, device_desc_default_get(vhdl), 
              sizeof (int), PCIIO_DMA_DATA |  PCIIO_FIXED);
              
      printf("map = 0x%x\n", soft->ps_ctl_dmamap);
      
}

/* ====================================================================
 *          CONTROL ENTRY POINT
 */
/*
 *    pciehci_ioctl: a user has made an ioctl request
 *      for an open character device.
 *      Arguments cmd and arg are as specified by the user;
 *      arg is probably a pointer to something in the user's
 *      address space, so you need to use copyin() to
 *      read through it and copyout() to write through it.
 */
/* ARGSUSED */
int pciehci_ioctl(dev_t dev, int cmd, void *arg, int mode, cred_t *crp, int *rvalp){
    char *data_in, *data_out;
    vertex_hdl_t vhdl = dev_to_vhdl(dev);
    EHCI_info_t EHCI_info;
    EHCI_ports_status_t EHCI_ports_status;
	EHCI_controller_info_t EHCI_controller_info;
    int i;
	
    pciehci_soft_t          soft = (pciehci_soft_t)device_info_get(vhdl);
    pciehci_regs_t          regs = soft->ps_regs;
    printf("pciehci_ioctl() regs=%x\n", regs);
    printf("cmd = 0x%x\n", cmd);	
	
	
    switch( cmd){
        case IOCTL_EHCI_DRIVER_INFO:{
	    printf("IOCTL_EHCI_DRIVER_INFO\n");
            strcpy( EHCI_info.long_name, PCIEHCI_DRV_LONG_NAME);
            strcpy( EHCI_info.short_name, PCIEHCI_DRV_SHORT_NAME);
            strcpy( EHCI_info.version, PCIEHCI_DRV_VERSION);
            strcpy( EHCI_info.short_version, PCIEHCI_DRV_SHORT_VERSION);
            strcpy( EHCI_info.seqn, PCIEHCI_DRV_SEQ);
            strcpy( EHCI_info.build_date, PCIEHCI_BUILD_DATE);
            copyout( (caddr_t) &EHCI_info, arg, sizeof( EHCI_info_t));
            return( 0);
		    
        }
        case IOCTL_EHCI_PORTS_STATUS:{
            printf("IOCTL_EHCI_PORTS_STATUS\n");
            EHCI_ports_status.num_ports = global_num_ports;
            for( i = 0; i < global_num_ports; i++)
                EHCI_ports_status.port[i] = global_ports_status[i];
        
            copyout( (caddr_t) &EHCI_ports_status, arg, sizeof( EHCI_ports_status_t));
            break;
        }
        case IOCTL_PCI_INFO:{
            printf("IOCTL_PCI_INFO\n");
            strcpy( EHCI_controller_info.device_string, soft->controller_desc.description);
            EHCI_controller_info.device_id = soft->controller_desc.vendor_id | (soft->controller_desc.device_id << 16);
            EHCI_controller_info.num_ports = soft->sc_noport;
            copyout( (caddr_t) &EHCI_controller_info, arg, sizeof( EHCI_controller_info_t));
            break;
        }

        default:
                printf("UNKNOWN IOCTL\n");
    }	
	

    *rvalp = -1;
    return 0;          /* TeleType is a registered trademark */
}
/* ====================================================================
 *          DATA TRANSFER ENTRY POINTS
 *      Since I'm trying to provide an example for both
 *      character and block devices, I'm routing read
 *      and write back through strategy as described in
 *      the IRIX Device Driver Programming Guide.
 *      This limits our character driver to reading and
 *      writing in multiples of the standard sector length.
 */
/* ARGSUSED */
int
pciehci_read(dev_t dev, uio_t * uiop, cred_t *crp)
{
    return physiock(pciehci_strategy,
                    0,          /* alocate temp buffer & buf_t */
                    dev,        /* dev_t arg for strategy */
                    B_READ,     /* direction flag for buf_t */
                    pciehci_size(dev),
                    uiop);
}
/* ARGSUSED */
int
pciehci_write(dev_t dev, uio_t * uiop, cred_t *crp)
{
    return physiock(pciehci_strategy,
                    0,          /* alocate temp buffer & buf_t */
                    dev,        /* dev_t arg for strategy */
                    B_WRITE,    /* direction flag for buf_t */
                    pciehci_size(dev),
                    uiop);
}
/* ARGSUSED */
int
pciehci_strategy(struct buf *bp)
{
    /*
     * XXX - create strategy code here.
     */
    return 0;
}
/* ====================================================================
 *          POLL ENTRY POINT
 */
int pciehci_poll(dev_t dev, short events, int anyyet,
           short *reventsp, struct pollhead **phpp, unsigned int *genp){

#define OUR_EVENTS (POLLIN|POLLOUT|POLLRDNORM)

    vertex_hdl_t            vhdl = dev_to_vhdl(dev);
    pciehci_soft_t          soft = (pciehci_soft_t)device_info_get(vhdl);
    pciehci_regs_t          regs = soft->ps_regs;
    short                   happened = 0;
    unsigned int            gen;
    short wanted = events & OUR_EVENTS;
               
    printf("pciehci_poll() regs=%x\n", regs);
    /*
     * Need to snapshot the pollhead generation number before we check
     * device state.  In many drivers a lock is used to interlock the
     * "high" and "low" portions of the driver.  In those cases we can
     * wait to do this snapshot till we're in the critical region.
     * Snapshotting it early isn't a problem since that makes the
     * snapshotted generation number a more conservative estimate of
     * what generation of  pollhead our event state report indicates.
     */
    /* 
    gen = POLLGEN(soft->ps_pollhead);
    if (events & (POLLIN | POLLRDNORM))
        if (soft->ps_sst & DEVICE_SST_RX_READY)
            happened |= POLLIN | POLLRDNORM;
    if (events & POLLOUT)
        if (soft->ps_sst & DEVICE_SST_TX_READY)
            happened |= POLLOUT;
    if (soft->ps_sst & DEVICE_SST_ERROR)
        happened |= POLLERR;
    *reventsp = happened;
    if (!happened && anyyet) {
        *phpp = soft->ps_pollhead;
        *genp = gen;
    }
    */

    gen = POLLGEN(soft->ps_pollhead);
    
    if (events & (POLLIN))
        if (soft->ps_event != 0){
           /*happened |= POLLIN | POLLRDNORM;*/
           happened = soft->ps_event;
           soft->ps_event = 0;
        }
    *reventsp = happened;
    if (!happened) {
        *phpp = soft->ps_pollhead;
        *genp = gen;
    }
    
    

    return 0;
}
/* ====================================================================
 *          MEMORY MAP ENTRY POINTS
 */
/* ARGSUSED */
int
pciehci_map(dev_t dev, vhandl_t *vt,
          off_t off, size_t len, uint_t prot)
{
    vertex_hdl_t            vhdl = dev_to_vhdl(dev);
    pciehci_soft_t          soft = (pciehci_soft_t)device_info_get(vhdl);
    vertex_hdl_t            conn = soft->ps_conn;
    pciehci_regs_t            regs = soft->ps_regs;
    pciio_piomap_t          amap = 0;
    caddr_t                 kaddr;
    printf("pciehci_map() regs=%x\n", regs);
    /*
     * Stuff we want users to mmap is in our second BASE_ADDR window.
     */
    kaddr = (caddr_t) pciio_pio_addr
        (conn, 0,
         PCIIO_SPACE_WIN(1),
         off, len, &amap, 0);
    if (kaddr == NULL)
        return EINVAL;
    /*
     * XXX - must stash amap somewhere so we can pciio_piomap_free it
     * when the mapping goes away.
     */
    v_mapphys(vt, kaddr, len);
    return 0;
}
/* ARGSUSED2 */
int
pciehci_unmap(dev_t dev, vhandl_t *vt)
{
    /*
     * XXX - need to find "amap" that we used in pciehci_map() above,
     * and if (amap) pciio_piomap_free(amap);
     */
    return (0);
}
/* ====================================================================
 *          INTERRUPT ENTRY POINTS
 *  We avoid using the standard name, since our prototype has changed.
 */
void
pciehci_dma_intr(intr_arg_t arg)
{
    pciehci_soft_t            soft = (pciehci_soft_t) arg;
	printf("pciehci_dma_intr()\n");
	printf("soft=0x%x arg=0x%x\n", soft, arg);
	if( soft == NULL){
	    soft = global_soft;
	}
	
/*
    vertex_hdl_t              vhdl = soft->ps_vhdl;
    pciehci_regs_t            regs = soft->ps_regs;

    cmn_err(CE_CONT, "pciehci soft=%x\n", soft);
*/
	printf("interrupt!! \n");
	USECDELAY(1000);
	ehci_interrupt( soft);
        /*pollwakeup( soft->ps_pollhead, POLLIN); */
    /*
     * for each buf our hardware has processed,
     *      set buf->b_resid,
     *      call pciio_dmamap_done,
     *      call bioerror() or biodone().
     *
     * XXX - would it be better for buf->b_iodone
     * to be used to get to pciio_dmamap_done?
     */
    /*
     * may want to call pollwakeup.
     */
}
/* ====================================================================
 *          ERROR HANDLING ENTRY POINTS
 */
static int
pciehci_error_handler(void *einfo,
                    int error_code,
                    ioerror_mode_t mode,
                    ioerror_t *ioerror)
{
    pciehci_soft_t            soft = (pciehci_soft_t) einfo;
    vertex_hdl_t            vhdl = soft->ps_vhdl;
#if DEBUG && ERROR_DEBUG
    cmn_err(CE_CONT, "%v: pciehci_error_handler\n", vhdl);
#else
    vhdl = vhdl;
#endif
    /*
     * XXX- there is probably a lot more to do
     * to recover from an error on a real device;
     * experts on this are encouraged to add common
     * things that need to be done into this function.
     */
    ioerror_dump("sample_pciio", error_code, mode, ioerror);
    return IOERROR_HANDLED;
}
/* ====================================================================
 *          SUPPORT ENTRY POINTS
 */
/*
 *    pciehci_halt: called during orderly system
 *      shutdown; no other device driver call will be
 *      made after this one.
 */
void
pciehci_halt(void)
{
    printf("pciehci_halt()\n");
}
/*
 *    pciehci_size: return the size of the device in
 *      "sector" units (multiples of NBPSCTR).
 */
int
pciehci_size(dev_t dev)
{
    vertex_hdl_t            vhdl = dev_to_vhdl(dev);
    pciehci_soft_t            soft = (pciehci_soft_t)device_info_get(vhdl);
    return soft->ps_blocks;
}
/*
 *    pciehci_print: used by the kernel to report an
 *      error detected on a block device.
 */
int
pciehci_print(dev_t dev, char *str)
{
    cmn_err(CE_NOTE, "%V: %s\n", dev, str);
    return 0;
}
